# ============================================================
# CD Pipeline â€“ GitHub Actions
# Deploys to Kubernetes via SSH into the control plane EC2 node.
# develop branch â†’ dev namespace
# main/master branch â†’ prod namespace
#
# Security: Requires CI pipeline to pass (includes Trivy scan).
# Safety: Includes rollback on failed deployment.
# ============================================================
name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [master, main, develop]

env:
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # â”€â”€ Gate: Only deploy if CI passed â”€â”€
  gate:
    name: "ðŸ”’ Security Gate"
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: CI passed â€” deployment approved
        run: |
          echo "## ðŸ”’ Security Gate" >> $GITHUB_STEP_SUMMARY
          echo "CI Pipeline (lint + test + Trivy scan) passed." >> $GITHUB_STEP_SUMMARY
          echo "Proceeding to deployment." >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [gate]
    steps:
      - uses: actions/checkout@v4

      - name: Check if deploy secrets are configured
        id: check
        run: |
          if [ -z "$CONTROL_PLANE_IP" ] || [ -z "$SSH_KEY" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "::warning::Skipping deploy â€” CONTROL_PLANE_IP or EC2_SSH_KEY secrets not set"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi
        env:
          CONTROL_PLANE_IP: ${{ secrets.CONTROL_PLANE_IP }}
          SSH_KEY: ${{ secrets.EC2_SSH_KEY }}

      - name: Determine target namespace
        if: steps.check.outputs.skip != 'true'
        id: namespace
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch || github.ref_name }}"
          if [ "$BRANCH" == "main" ] || [ "$BRANCH" == "master" ]; then
            echo "namespace=prod" >> $GITHUB_OUTPUT
            echo "overlay=prod" >> $GITHUB_OUTPUT
          else
            echo "namespace=dev" >> $GITHUB_OUTPUT
            echo "overlay=dev" >> $GITHUB_OUTPUT
          fi

      - name: Setup SSH Key
        if: steps.check.outputs.skip != 'true'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/bastion-11-1-26.pem
          chmod 600 ~/.ssh/bastion-11-1-26.pem
          ssh-keyscan -H ${{ secrets.CONTROL_PLANE_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Update image tags in manifests
        if: steps.check.outputs.skip != 'true'
        run: |
          cd ecommerce-platform/infra/k8s/base
          for file in frontend.yaml user-service.yaml product-service.yaml order-service.yaml payment-service.yaml; do
            sed -i "s|image: asylums/.*:.*|image: asylums/$(echo $file | sed 's/.yaml//'):${IMAGE_TAG}|g" $file
          done

      - name: Copy manifests to control plane
        if: steps.check.outputs.skip != 'true'
        run: |
          scp -i ~/.ssh/bastion-11-1-26.pem -r ecommerce-platform/infra/k8s/ \
            ubuntu@${{ secrets.CONTROL_PLANE_IP }}:/tmp/k8s-manifests/

      - name: Save current state for rollback
        if: steps.check.outputs.skip != 'true'
        id: rollback
        run: |
          ssh -i ~/.ssh/bastion-11-1-26.pem ubuntu@${{ secrets.CONTROL_PLANE_IP }} << 'ROLLBACK_PREP'
            export KUBECONFIG=/home/ubuntu/.kube/config
            NS="${{ steps.namespace.outputs.namespace }}"
            # Save current deployment images for rollback
            for deploy in frontend user-service product-service order-service payment-service; do
              kubectl get deployment/$deploy -n $NS -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null \
                > /tmp/rollback-$deploy.txt || echo "none" > /tmp/rollback-$deploy.txt
            done
            echo "Rollback state saved."
          ROLLBACK_PREP

      - name: Deploy to Kubernetes
        if: steps.check.outputs.skip != 'true'
        id: deploy
        run: |
          ssh -i ~/.ssh/bastion-11-1-26.pem ubuntu@${{ secrets.CONTROL_PLANE_IP }} << 'DEPLOY_SCRIPT'
            set -e
            export KUBECONFIG=/home/ubuntu/.kube/config
            echo ">>> Deploying to ${{ steps.namespace.outputs.namespace }} namespace..."
            kubectl apply -k /tmp/k8s-manifests/k8s/${{ steps.namespace.outputs.overlay }}/
            echo ">>> Waiting for deployments to roll out..."
            FAILED=0
            for deploy in frontend user-service product-service order-service payment-service; do
              kubectl rollout status deployment/$deploy \
                -n ${{ steps.namespace.outputs.namespace }} \
                --timeout=300s || FAILED=1
            done
            if [ $FAILED -eq 1 ]; then
              echo "::error::One or more deployments failed to roll out"
              exit 1
            fi
            echo ">>> Deployment complete!"
            kubectl get pods -n ${{ steps.namespace.outputs.namespace }}
          DEPLOY_SCRIPT

      - name: Rollback on failure
        if: failure() && steps.check.outputs.skip != 'true' && steps.deploy.outcome == 'failure'
        run: |
          echo "## âš ï¸ Deployment failed â€” rolling back!" >> $GITHUB_STEP_SUMMARY
          ssh -i ~/.ssh/bastion-11-1-26.pem ubuntu@${{ secrets.CONTROL_PLANE_IP }} << 'ROLLBACK_SCRIPT'
            export KUBECONFIG=/home/ubuntu/.kube/config
            NS="${{ steps.namespace.outputs.namespace }}"
            echo ">>> Rolling back deployments..."
            for deploy in frontend user-service product-service order-service payment-service; do
              kubectl rollout undo deployment/$deploy -n $NS 2>/dev/null || true
            done
            echo ">>> Rollback complete. Current state:"
            kubectl get pods -n $NS
          ROLLBACK_SCRIPT

      - name: Post-deploy health check
        if: steps.check.outputs.skip != 'true' && steps.deploy.outcome == 'success'
        run: |
          ssh -i ~/.ssh/bastion-11-1-26.pem ubuntu@${{ secrets.CONTROL_PLANE_IP }} << 'HEALTHCHECK'
            export KUBECONFIG=/home/ubuntu/.kube/config
            NS="${{ steps.namespace.outputs.namespace }}"
            echo ">>> Running health checks..."

            # Wait for pods to be ready
            sleep 10
            NOT_READY=$(kubectl get pods -n $NS --no-headers | grep -v "Running\|Completed" | wc -l)
            if [ "$NOT_READY" -gt 0 ]; then
              echo "::warning::$NOT_READY pods not in Running state"
              kubectl get pods -n $NS --no-headers | grep -v "Running\|Completed"
            else
              echo "âœ… All pods healthy"
            fi

            # Print resource usage
            echo ">>> Resource usage:"
            kubectl top pods -n $NS 2>/dev/null || echo "(metrics-server not available)"
          HEALTHCHECK

      - name: Cleanup SSH key
        if: always() && steps.check.outputs.skip != 'true'
        run: rm -f ~/.ssh/bastion-11-1-26.pem

      - name: Deployment Summary
        if: always() && steps.check.outputs.skip != 'true'
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.event.workflow_run.head_branch || github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ steps.namespace.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${IMAGE_TAG}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Status**: ${{ steps.deploy.outcome || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Gate**: CI Pipeline passed âœ…" >> $GITHUB_STEP_SUMMARY
